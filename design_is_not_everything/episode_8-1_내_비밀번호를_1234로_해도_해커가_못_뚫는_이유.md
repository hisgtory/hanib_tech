# Episode 8-1: "내 비밀번호를 1234로 해도 해커가 못 뚫는 이유"

*미스터리 코드의 비밀을 파헤치다*

---

## 🔍 프롤로그: 2024년 어느 날, 불가능한 사건이 일어났다

2024년 3월 15일, 오후 2시 30분.

국내 대형 포털 사이트 N사의 보안팀에 긴급 상황이 발생했다. 해커들이 사용자 데이터베이스를 털어갔다는 것이다. 1억 명의 사용자 정보가 담긴 DB가 통째로 유출되었다.

하지만 이상한 일이 일어났다.

해커들은 분명 모든 데이터를 가져갔지만, 실제로는 아무것도 얻지 못했다. 마치 금고를 털었는데 안에 있던 건 의미 없는 암호문뿐이었던 것처럼.

**이것은 어떻게 가능한 일일까?**

---

## 🕵️ 사건 파일 #1: 해커가 훔친 것은 정확히 무엇인가?

### 범행 현장의 증거들

해커가 훔쳐간 데이터베이스를 살펴보자:

```
사용자 ID: hanib_tech
비밀번호: $2b$12$LnqzF8k6tP.uX4Z9vR7aXeJ3mKdQ5wE8sC1yA6vB9nF2jH4iP0oL7M
```

```
사용자 ID: marketer_kim  
비밀번호: $2b$12$R8dF3kP9mZ.vY7B2qE6cWeM4jLaQ8wR5sD9yC3vE6nG1iH7oN2mK8L
```

이상하다. 비밀번호가 '1234'나 'password123' 같은 단순한 형태가 아니라 완전히 다른 이상한 문자열로 되어 있다.

### 첫 번째 단서: 길이의 수수께끼

모든 비밀번호가 동일한 길이(60자)를 가지고 있다는 점이 수상하다. 실제 사용자가 입력한 비밀번호 길이가 모두 같을 리 없는데...

**탐정의 추론**: 이것들은 실제 비밀번호가 아니다. 뭔가 다른 것으로 변환된 형태다.

---

## 🔬 사건 파일 #2: 해시라는 마법의 정체

### 단방향 마법의 비밀

웹사이트가 비밀번호를 저장하는 방식을 추적해보자:

**1단계: 사용자가 '1234' 입력**
```
원본 비밀번호: 1234
```

**2단계: 해시 함수 적용**
```
해시 함수(1234) → $2b$12$LnqzF8k6tP.uX4Z9vR7aXe...
```

**3단계: 데이터베이스에 저장**
```
실제 저장된 값: $2b$12$LnqzF8k6tP.uX4Z9vR7aXe...
원본 비밀번호 '1234'는 어디에도 없다!
```

### 해시 함수의 미스터리한 특성

해시 함수는 마치 마법의 고기 분쇄기 같다:

🥩 **고기를 넣으면** → 🍖 **다진 고기가 나온다**
- 같은 고기를 넣으면 항상 같은 다진 고기가 나온다
- 하지만 다진 고기를 보고 원래 어떤 고기였는지 알 수 없다
- 다진 고기를 다시 원래 고기로 되돌릴 수 없다

```
"password123" → SHA-256 → ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
"password124" → SHA-256 → a2c8c9f51e7a8c2b9d6e4f3a1b5c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5
```

한 글자만 달라져도 완전히 다른 결과가 나온다!

---

## 🧂 사건 파일 #3: Salt와 Pepper의 비밀 양념

### 레인보우 테이블의 함정

영리한 해커들은 '레인보우 테이블'이라는 무기를 가지고 있다:

```
1234     → 03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4
password → 5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8
123456   → e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

이미 계산된 해시값들의 거대한 사전이다. 하지만 현대적인 웹사이트들은 이미 이 함정을 알고 있었다.

### Salt: 각각 다른 비밀 양념

```
사용자 A의 '1234':
Salt: $2b$12$LnqzF8k6tP.uX4Z9vR7aXe
실제 해시: hash(1234 + Salt) → 완전히 독특한 결과

사용자 B의 '1234': 
Salt: $2b$12$R8dF3kP9mZ.vY7B2qE6cWe  
실제 해시: hash(1234 + 다른Salt) → 완전히 다른 결과
```

같은 비밀번호여도 각 사용자마다 다른 해시값을 갖게 된다!

### Pepper: 서버만 아는 최후의 비밀

```
최종 해시 = hash(비밀번호 + Salt + Pepper)
```

Pepper는 데이터베이스가 아닌 서버 코드에 숨겨져 있다. 해커가 DB를 털어도 Pepper는 모른다.

---

## 🛡️ 사건 파일 #4: bcrypt vs Argon2, 현대 암호화의 전쟁

### 시간이라는 무기

일반 해시 함수(SHA-256):
```
1초에 10억 번 계산 가능 ⚡
```

bcrypt (현재 사건의 주인공):
```
1초에 100번만 계산 가능 🐌
하지만 이것이 바로 장점!
```

### bcrypt의 시간 지연 전술

```python
# 해커의 무차별 대입 공격
일반 해시: "1234" 확인 → 0.000001초
bcrypt: "1234" 확인 → 0.01초

1만 개 비밀번호 시도할 때:
일반 해시: 0.01초로 끝남
bcrypt: 100초(1분 40초) 소요
```

비밀번호가 복잡할수록 해커가 포기할 때까지 걸리는 시간이 기하급수적으로 늘어난다.

### Argon2: 차세대 방어막

```
메모리 사용량까지 조절 가능
GPU로 병렬 처리해도 비효율적
현재 가장 안전한 암호화 방식
```

---

## 🎭 에pilogue: 그래도 복잡한 비밀번호를 써야 하는 이유

### 완벽한 방어는 없다

우리의 탐정 수사 결과:

1. **DB 유출 ≠ 비밀번호 유출**: 해시된 값만 털려간다
2. **Salt**: 같은 비밀번호도 각각 다르게 보인다  
3. **느린 해시**: 시간이 해커의 적이다
4. **Pepper**: 서버만 아는 최후의 비밀

### 하지만 여전히 '1234'는 위험하다

```
'1234' 크랙 시도 횟수: 4번째
'MyP@ssw0rd2024!' 크랙 시도 횟수: 수조 번째
```

아무리 강력한 해시라도, 단순한 비밀번호는 몇 번 시도하지 않아도 뚫린다.

### 진짜 보안의 공식

```
복잡한 비밀번호 + 강력한 해시 + Salt + Pepper = 뚫기 거의 불가능
```

---

## 🔍 사건 종료: hanib_tech의 결론

이번 사건을 통해 우리가 배운 것:

**기술적 관점에서:**
- 해시는 단방향 함수다 (되돌릴 수 없다)
- Salt는 같은 비밀번호도 다르게 만든다
- 느린 해시 함수가 오히려 더 안전하다
- Pepper는 추가적인 서버 보안이다

**실용적 관점에서:**
- DB가 털려도 당황하지 말자 (해시된 값만 유출)
- 그래도 복잡한 비밀번호를 쓰자
- 2단계 인증은 필수다
- 정기적인 비밀번호 변경은 여전히 중요하다

**마케터/기획자가 개발자와 대화할 때:**
- "비밀번호를 평문으로 저장하나요?" → 절대 안 된다는 걸 안다
- "해시 함수는 뭘 쓰나요?" → bcrypt, Argon2면 안심
- "Salt는 적용되나요?" → 기본 중의 기본
- "DB가 털려도 안전한가요?" → 이제 이유를 안다

---

**다음 에피소드 예고**: "왜 내 카드 정보는 해커가 봐도 모를까? - 토큰화의 비밀"

*해커가 결제 데이터를 훔쳐도 실제로는 의미 없는 숫자만 가져가는 토큰화 기술의 신비한 세계로...*

---

### 💡 TMI Box: 실제 해시 함수 체험해보기

```bash
# 같은 입력, 같은 결과
echo -n "1234" | sha256sum
# → 03ac674216f3e15c761ee1a5e255f067953623c8b388b4459e13f978d7c846f4

# 한 글자만 바뀌어도 완전히 다른 결과  
echo -n "1235" | sha256sum  
# → 4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a
```

---

**#해시함수 #보안 #비밀번호 #개발자와소통하기 #hanib_tech**